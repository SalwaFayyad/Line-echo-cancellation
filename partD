close all;
clear all;
clc;

load('path.mat');
load('css.mat');

far_end_signal = repmat(css, [1, 10]); % Repeat CSS data for 10 blocks
echo_signal = conv(path, far_end_signal);
desired_signal = echo_signal;

filter_length = 128; % Number of filter taps
step_size = 6e-10; % NLMS step size
mu = 0.25; % Step size for NLMS algorithm
adapt_filter = zeros(filter_length, 1); % Initialize adaptive filter coefficients

% Initialize error signal with the size of far_end_signal
error_signal = zeros(length(far_end_signal), 1);

% Apply the NLMS algorithm to train the adaptive filter
for n = filter_length:length(far_end_signal)
    x = far_end_signal(n:-1:n-filter_length+1)';
    y = adapt_filter' * x;
    error = desired_signal(n) - y;
    adapt_filter = adapt_filter + (step_size * x * error) / (norm(x)^2 + mu);
    error_signal(n) = error;
end

% Plotting the signals and estimated echo path
figure;
subplot(5, 1, 1);
plot(far_end_signal);
title('Far-End Signal');
subplot(5, 1, 2);
plot(echo_signal);
title('Echo Signal');
subplot(5, 1, 3);
plot(error_signal);
title('Error Signal');
subplot(5, 1, 4);
plot(path);
title('Echo Path');
subplot(5, 1, 5);
plot(conv(far_end_signal, adapt_filter));
title('Estimated Echo Path');
